[{"ver":"0.1","info":{"id":"WtcSDn","date":"1580800669","viewed":450,"name":"Wuhan Coronavirus 2020","username":"senzheng","description":"FXXK the Red Cross of Wuhan City & Hubei Province...","likes":10,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":".\/media\/a\/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":".\/media\/ap\/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":".\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":".\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n    Virus\n\n  - Created by SEN ZHENG - 2020\/02\/04\n  - The idea of model is from \u706b\u4eba\n  - FXXK the Red Cross of Wuhan City & Hubei Province...\n*\/\n\n#define MAX_RAYMARCHING_COUNT 80\n#define PRECISION 0.0001\n#define FAR 4.\n#define mouse (iMouse.xy \/ iResolution.xy)\n#define time iTime\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\n\/\/iq's ubiquitous 3d noise\nvec3 noise(float p){return texture(iChannel0,vec2(p\/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p\/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){\n    float m = mod(p.z,1.0);\n    float s = p.z-m; \n    float sprev = s-1.0;\n    if (mod(s,2.0)==1.0) { \n        s--; sprev++; m = 1.0-m; \n    };\n    return mix(texture(iChannel0,p.xy\/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy\/iChannelResolution[0].xy+noise(s).yz).xyz,m);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvoid move(inout vec3 p) {\n    p += vec3(cos(time*0.1), sin(time*0.1), cos(sin(time*0.1)*6.0))*0.3;\n    float r = time \/ 6.;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n   \tp.xz *= rot;\n    p.zy *= rot;\n}\n\nHit Virus(vec3 p) {\n    \n    move(p);\n    \n    vec3 np = p*40.0;\n    \n    float spd = 1.0;\n    float t = iTime*spd;\n    float f = 0.;\n    float s = 1.0;\n    float sum = 0.;\n    for (float i = 0. ; i < 2.0 ; i++) {\n    \tnp += t;\n        t *= 2.0;\n        f += s * (noise( np ).x-0.5)*2.0;\n        np = np * 2.01;\n        sum += s;\n        s *= 0.62;\n    }\n    f \/= sum;\n    \n    float d = length(p + f*0.01) - 1.0;\n    \n    \/\/ red 10\n    float len = 0.2;\n    p = fold(p + f*0.003);\n\tvec3 point = geodesicTri(p, 1.0);\n    vec3 pp = p - point;\n\n    d = opSmoothUnion(d, sdCapsule(pp, vec3(0.0), vec3(0.0, 0.0, len), 0.02), 0.2);\n    float backupD = d;\n    \n    float dred = sdRoundBox(pp - vec3(0.0, 0.0, len), vec3(0.2, 0.03, 0.005)*0.5, 0.02);\n    dred = opSmoothUnion(dred, sdRoundBox(pp - vec3(0.0, 0.0, len), vec3(0.03, 0.2, 0.005)*0.5, 0.02), 0.03);\n\n\td = opSmoothUnion(d, dred, 0.02);\n    \n    float factor = (d - backupD)\/(dred - backupD);\n    \n    vec3 col0 = vec3(0.3, 1.0, 0.5);\n    vec3 col1 = vec3(1.2, 0.1, 0.1);\n    vec3 col = mix(col0, col1, factor);\n    \n    float lightStrength0 = 0.05;\n    float lightStrength1 = 0.6;\n    float lightStrength = mix(lightStrength0, lightStrength1, factor);\n    \n    float refl0 = 0.6;\n    float refl1 = 1.0;\n    float refl = mix(refl0, refl1, factor);\n    \n    float sss0 = 0.7;\n    float sss1 = 0.1;\n    float sss = mix(sss0, sss1, factor);\n    \n    \n    return Hit(d, vec2(0.0), col, refl, 1.0, 0.0, d, col, lightStrength, sss);\n}\n\nHit map2(vec3 p) {\n    Hit res = Virus(p);\n    return res;\n}\n\n\nvec3 calcuNormal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + \n                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map2( ro + rd*t ).d;\n        res = min( res, 5.0*h\/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcThickness( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = -map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 samplepos) {\n    Hit hitdata;\n    float t = 0.0;\n    float told = t, mid, dn;\n    float d = map2(rd*t + ro).d;\n    float sgn = sign(d);\n\n    if (sgn < 0.0) return vec4(0);\n    \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    vec3 bgCol = pow(vec3(max(0.0, dot(rd, -normalize(ro))))*0.5, vec3(1.5)) * vec3(1.0, 1.05, 1.15);\n    \n    \/\/ light source\n    vec3 lp = vec3(-ro.x, 4.0, -ro.z);\n    vec3 lCol = vec3(1.05, 1.1, 1.0);\n    \n    vec3 atm = vec3(0.0);\n    float att = 1.0;\n    \n    float forwardstep = FAR \/ float(MAX_RAYMARCHING_COUNT);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n        \n        vec3 sp = ro + rd*t;\n        vec3 sundir = lp - sp;\n        float sundist = length(sundir);\n        vec3 ld = normalize(sundir);\n        \n        hitdata = map2(rd*t + ro);\n        d = hitdata.d;\n        \n        float illum = 0.0;\n        illum = 4.0 \/ (hitdata.lightD*hitdata.lightD+0.0001);\n        atm += illum * 0.00005 * att * hitdata.lightCol * hitdata.lightStrength;\n        \n        if (sign(d) != sgn || d < PRECISION) {\n            \n            vec3 nor = normalize(calcuNormal(sp));\n            float shd = calcSoftshadow( sp, ld, 0.02, FAR );\n            float occ = calcAO( sp, nor );\n            float thickness = calcThickness( sp-nor*0.01, ld);\n            float fresnel = 0.7 + 0.3 * pow(1.0 - clamp(dot(-rd, nor),0.0,1.0), 4.0);\n            \n            vec3 hal = normalize( lp - rd );\n            float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n            float dif = max( dot( ld, nor ), 0.0);\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0);\n            float bac = clamp( dot( nor, normalize(vec3(lp.x,-lp.y,lp.z))), 0.0, 1.0 );\n            \n            \/\/ surface color\n            col = hitdata.col;\n            \/\/col = mix(hitdata.col*0.4, hitdata.col, 2.0*(fresnel-0.5));\n            \n            vec3 lin = lCol * dif;\n            lin += 0.3*amb*vec3(1.0);\n            lin += 0.3*bac*vec3(1.0);\n            lin += hitdata.spe*spe*lCol * shd;\n            col *= lin * occ;\n            \n            \/\/ reflect\n            vec3 r = reflect(rd, nor);\n    \t\tcol += texture( iChannel1, r ).xyz * hitdata.ref * fresnel;\n    \t\tcol += texture( iChannel1, r ).xyz * hitdata.ref * fresnel;\n            \n            \/\/ Fake SSS\n            col = mix(col, lCol*hitdata.col, (1.0 - thickness)*hitdata.sss);\n            \n            col = mix(col, bgCol, smoothstep(0.5, FAR, t));\n\n            break;\n        } else if (t >= FAR || i+1 == MAX_RAYMARCHING_COUNT) {\n            col = bgCol;\n            break;\n        }\n        att *= 0.98;\n        \n        told = t;\n        t += d;\n        t = min(FAR, t);\n    }\n    \n    \/\/ Light\n    \/\/col += atm*0.1;\n    col = pow(col, vec3(1.3));\n    \n    return vec4(col, t);\n}\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt-ro);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    init();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n    \n    float dist = 2.0;\n    vec3 ro = vec3(sin(time*0.5 + mouse.x*5.0)*dist, 0.0, cos(time*0.5 + mouse.x*5.0)*dist);\n    vec3 lookAt = vec3(0.0);\n    vec3 camup = vec3(0.0, 1.0, 0.0);\n    mat3 viewMat = setCamera(ro, lookAt, camup);\n    \n    vec3 rd = viewMat * normalize(vec3(p, 1.));\n    vec4 col = render( ro, rd, p );\n\n    fragColor = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nstruct Hit {\n    float d;\n    vec2 uv;\n    vec3 col;\n    float ref;\n    float spe;\n    float rough;\n    float lightD;\n    vec3 lightCol;\n    float lightStrength;\n\tfloat sss;\n};\n    \n\/\/ The codes below are from http:\/\/glslsandbox.com\/e#38339.0\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nfloat edgeLength;\nfloat faceRadius;\n\nvoid init() {\n    float cospin=cos(PI\/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n\n    \/\/ Edge length of an icosahedron with an inscribed sphere of radius of 1\n    edgeLength = 1. \/ ((sqrt(3.) \/ 12.) * (3. + sqrt(5.)));\n    \/\/ Inner radius of the icosahedron's face\n    faceRadius = (1.\/6.) * sqrt(3.) * edgeLength;\n\n}\n\nvec3 fold(vec3 p) {\n\t\/*for(int i=0 ; i<5 ; i++){\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}*\/\n    \n    p.xy = abs(p.xy);\n    p -= 2. * min(0., dot(p,nc)) * nc;\n    p.xy = abs(p.xy);\n    p -= 2. * min(0., dot(p,nc)) * nc;\n    p.xy = abs(p.xy);\n    p -= 2. * min(0., dot(p,nc)) * nc;\n    p.xy = abs(p.xy);\n    p -= 2. * min(0., dot(p,nc)) * nc;\n    p.xy = abs(p.xy);\n    p -= 2. * min(0., dot(p,nc)) * nc;\n    return p;\n}\n\n\/\/ --------------------------------------------------------\n\/\/ Triangle tiling\n\/\/ Adapted from mattz https:\/\/www.shadertoy.com\/view\/4d2GzV\n\/\/\n\/\/ Finds the closest triangle center on a 2D plane \n\/\/ --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2tri = mat2(1, 0, i3, 2. * i3);\nconst mat2 tri2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvec2 closestTri(vec2 p) {\n    p = cart2tri * p;\n    vec2 pf = fract(p);\n    vec2 v = vec2(1.\/3., 2.\/3.);\n    vec2 tri = mix(v, v.yx, step(pf.y, pf.x));\n    tri += floor(p);\n    tri = tri2cart * tri;\n    return tri;\n}\n\n\/\/ --------------------------------------------------------\n\/\/ Geodesic tiling\n\/\/\n\/\/ Finds the closest triangle center on the surface of a\n\/\/ sphere:\n\/\/ \n\/\/ 1. Intersect position with the face plane\n\/\/ 2. Convert that into 2D uv coordinates\n\/\/ 3. Find the closest triangle center (tile the plane)\n\/\/ 4. Convert back into 3D coordinates\n\/\/ 5. Project onto a unit sphere (normalize)\n\/\/\n\/\/ You can use any tiling method, such as one that returns\n\/\/ hex centers or adjacent cells, so you can create more\n\/\/ interesting geometry later.\n\/\/ --------------------------------------------------------\n\n\/\/ Intersection point of vector and plane\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal) + planeOffset) \/ -denominator;\n    return n * t;\n}\n\n\/\/ 3D position -> 2D (uv) coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 i = intersection(normalize(p), facePlane, -1.0);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n\/\/ 2D (uv) coordinates -> 3D point on a unit sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\n\/\/ Closest geodesic point (triangle center) on unit sphere's surface\nvec3 geodesicTri(vec3 p, float subdivisions) {\n    \/\/ faceRadius is used as a scale multiplier so that our triangles\n    \/\/ always stop at the edge of the face\n\tfloat uvScale = subdivisions \/ faceRadius \/ 2.;\n\n    vec2 uv = icosahedronFaceCoordinates(p);\n    vec2 tri = closestTri(uv * uvScale);\n    return faceToSphere(tri \/ uvScale);\n}\n\n\n","name":"Common","description":"","type":"common"}]}]