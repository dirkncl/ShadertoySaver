[{"ver":"0.1","info":{"id":"wljczh","date":"1593747197","viewed":53,"name":"Apollonian Box VR","username":"pjkarlik","description":"another apollonian variation - trying to understand the formulas out there. Better at full screen to see details.\nClick to zoom and rotate\/spin - VR ready and is pretty nice!","likes":5,"published":3,"flags":1,"tags":["fractal","raymarch","apollonian","vr"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\n\/\/ APOLLONIAN BOX\n\/\/\n\n\/\/ shader inspiration and help\n\/\/ https:\/\/www.shadertoy.com\/view\/llG3Dt @Gijs\n\/\/ https:\/\/www.shadertoy.com\/view\/Xtlyzl @GregRostami \/ @Fabrice\n\n#define MAX_DIST \t15.0\n#define MIN_DIST \t.001\n#define MAX_STEPS \t156\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n#define R \t\t\tiResolution\n#define T\t\t\tiTime\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define kf(a,b) a*(1.2\/b)\n#define pfract(a) -1.+2.*fract(.5*a+.5);\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\nfloat vrmap = 0.;\n\nvec3 get_mouse( vec3 ro ) {\n    float x = iMouse.xy==vec2(0) ? .5 :\n    \t(iMouse.y \/ iResolution.y * 1. - .5) * PI;\n    float y = iMouse.xy==vec2(0) ? .5 :\n    \t-(iMouse.x \/ iResolution.x * 2. - 1.) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n\n\/\/all my sdf belong to @iq\nfloat sdbox(vec3 p, vec3 s) {\n  \tvec3 d = abs(p-vec3(0.)) - s;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec4 orb;\nvec2 apollo (vec3 p) {\n\n    vec3 f = p;\n\tfloat scale = 1.;\n\torb = vec4(0.0); \n    \n\tfor( int i=0; i<3;i++ ) {\n\t\tp = pfract(p);\n\t\tfloat r2 = dot(p,p);  \n        orb = min( orb, vec4(abs(p),r2) );\n\t\tp = kf(p,r2);\n        scale = kf(scale,r2);\n\t}\n    \n    float m = 1.;\n    float tubes = length(mod(p.xz+.5,1.)-.5)-.025;\n    tubes =   min(length(mod(p.xy+.5,1.)-.5)-.025,tubes);\n    tubes =   min(length(mod(p.zy+.5,1.)-.5)-.025,tubes);\n\n    float d = (tubes)\/scale;\n    \/\/box mask\n    float bx = sdbox(f,vec3(1.5,.75,.75));\n    d = max(d*.7,bx);\n\treturn vec2(d,scale);\n}\n\nvec2 room (vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n    vec3 q = p;\n\n    \/\/ room   \n    float b1 = sdbox(q-vec3(0.,3.45,0.), vec3(5.25,5.25,5.25));  \n    b1 = max(b1,-sdbox(q-vec3(0.,3.45,0.), vec3(5.15,5.15,5.15)));\n    if(b1<res.x) res=vec2(b1*.9,85.);\n   \n    \n    \/\/box frame\n    float frm = sdbox( p,vec3(1.55,.80,.50) );\n   \tfrm = max(-sdbox(p+vec3(0.,0.,.05),vec3(1.5,.75,1.85)),frm);\n    if(frm<res.x) res = vec2(frm,75.);\n    \n    return res;\n}\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n    p.y-=.15;\n    if(iMouse.z<1. && vrmap == 0.) p.xz*=r2(iTime*.1);\n    vec2 d = apollo(p);\n    if(d.x<res.x) res = d;\n    \n\tvec2 r = room(p);\n    if(r.x<res.x) res = r;\n              \n\treturn res;\n}\n\nvec3 get_normal(in vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001,.0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd ) {\n    float depth = 0.0;\n    float m = -1.;\n    for (int i = 0; i<MAX_STEPS;i++)\n    {\n        vec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        m = dist.y;\n        if(abs(dist.x)<MIN_DIST*depth) break;\n        depth += dist.x*.75;\n        if(depth>MAX_DIST) break;\n    } \n    return vec2(depth,m);\n}\n\nfloat get_diff(vec3 p, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    vec3 n = get_normal(p);\n    float dif = clamp(dot(n,l),0. , 1.);\n    vec2 shadow = ray_march(p + n * MIN_DIST * 2., l);\n    if(shadow.x < length(p -  lpos)) dif *= .1;\n    return dif;\n}\n\n\nfloat get_ao(vec3 p, vec3 n){ \/\/@iq & @shane - i like your ao <3\n    float r = 0., w = 1., d;\n    for (float i=1.; i<3.+1.1; i++){\n        d = i\/5.;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 get_color(float m, vec3 p) {\n    vec3 n = get_normal(p);\n    vec3 tint = hsv2rgb(vec3(m*.005,1.,.5));\n    if(m==4.) tint = tex3D(iChannel1,p*.5,n);         \n    if(m==5.) tint = vec3(.4,.02,.001)*hash(floor(p.x),floor(p.y*p.z))*.3;\n    return tint;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 color = vec3(0.);\n    vec3 fadeColor = vec3(0.005);\n    vec2 ray = ray_march(ro, rd);\n    \n    if(ray.x<MAX_DIST) {\n        vec3 p = ro + ray.x * rd;\n        vec3 n = get_normal(p);\n        \/\/ lighting and shade\n        vec3 lpos1 = vec3(-.2, .75, -2.5);\n        vec3 lpos2 = vec3(.2, 1.75, 2.5);\n        vec3 diff = vec3(.7)*get_diff(p, lpos1) + vec3(.2)*get_diff(p, lpos2);\n  \t\tfloat ao = get_ao(p,n);\n\t\tvec3 tint = get_color(ray.y, p);\n        color += tint * diff * ao;\n\n        \/\/ single bounce reflect \n        if ( ( ray.y==75. || ray.y==85. ) && vrmap == 0.) { \/\/ rando ID\n            vec3 rr=reflect(rd,n);\n            ray=ray_march(p,rr);\n            if(ray.x<MAX_DIST){\n                p+=ray.x*rr;\n                tint = get_color(ray.y, p);\n                diff = vec3(.7)*get_diff(p, lpos1) + vec3(.2)*get_diff(p, lpos2);\n                color += tint * diff ;\n            }\n        }\n    } else {\n    \tcolor = fadeColor;   \n    }\n\n    return color;\n}\n\nvec3 ray( in vec3 ro, in vec3 lp, in vec2 uv ) {\n    vec3 cf = normalize(lp-ro);\n    vec3 cp = vec3(0.,1.,0.);\n    vec3 cr = normalize(cross(cp, cf));\n    vec3 cu = normalize(cross(cf, cr));\n    vec3 c = ro + cf * .85;\n    \n    vec3 i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (2.*fragCoord.xy-R.xy)\/max(R.x,R.y);\n\tfloat zoom = iMouse.z > 0. ? 1.15 : 2.5;\n \tfloat tm = T*.1;\n    vec3 ro = vec3(0.,0.1,-zoom);\n    vec3 lp = vec3(0.,0.,0.);\n    ro = get_mouse(ro);\n\tvec3 rd = ray(ro, lp, uv);\n\n    \n    vec3 col = render(ro, rd, uv);\n    col= pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}\n\n\/\/ VR minus Reflections.\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n  \tvec2 uv = (2.*fragCoord.xy-R.xy)\/max(R.x,R.y);\n\tvrmap = 1.;\n    vec3 color = render(fragRayOri, fragRayDir, uv);\n\tcolor = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}]